lambda:
    regex: '->|Î»'
    formatter: '(lambda _=None: {token:1->st})'

unary_coalesce_none_dot:
    # Matches a?.attribute.
    regex: "\\?(?<inner>\\.[\\w_][\\w\\d_]*)"
    formatter: "({token:-1}{group:inner} if {token:-1} is not None else None)"

unary_coalesce_none_sqb:
    # Matches a?[i] when the brackets are balanced.
    regex: "\\?(?<inner>(?<balanced_sqb>\\[[^][]*+(?:(?&balanced_sqb)[^][]*)*+\\]))"
    formatter: "({token:-1}{group:inner} if {token:-1} is not None else None)"

unary_coalesce_none_par:
    # Matches fn?(x, y), fn?$(x, y)...
    regex: "\\?(?<inner>\\w*\\$?\\w*(?<balanced_parens>\\([^)(]*+(?:(?&balanced_parens)[^)(]*)*+\\)))"
    formatter: "({token:-1}{group:inner} if {token:-1} is not None else None)"

iterator_slicer:
    # Matches $[...].
    regex: '\\$(?P<slice>\\[[^\\[\\]]*\\])'
    formatter: 'lindworm.LindwormIteratorSlicer({token:-1}){group:slice}'

curry:
    # Matches $(...).
    # Hellish parenthesis matching
    regex: '\\$(?<inner>\\w*(?<balanced_parens>\\([^)(]*+(?:(?&balanced_parens)[^)(]*)*+\\)))'
    formatter: 'lindworm.curry({token:-1}, *[{group:inner->[1:-1]}])'


# Augmented EQ
none_coalescing_eq:
    regex: '(\\?\\?=)'
    formatter: '{token:-1} = ({token:-1} if {token:-1} is not None else {token:1})'


# 2-ary operators
binary_coalesce_none:
    regex: '(\\?\\?)'
    formatter: '({token:-1} if {token:-1} is not None else {token:1})'

binary_compose_right:
    regex: '\\.\\.(?<stars>(?>\\w*\\*\\w*)*)>?'
    formatter: 'lindworm.compose({token:-1}, {token:1}, True, { group:stars -> len })'

binary_compose_left:
    regex: '<(?<stars>(?>\\w*\\*\\w*)*)\\.\\.'
    formatter: 'lindworm.compose({token:-1}, {token:1}, False, { group:stars -> len })'

binary_pipe_right:
    regex: '\\|(?<stars>(?>\\w*\\*\\w*)*)>'
    formatter: '({token:1}({group:stars}{token:-1}))'

binary_pipe_left:
    regex: '<(?<stars>(?>\\w*\\*\\w*)*)\\|'
    formatter: '({token:-1}({group:stars}{token:1}))'


# Datatype shorthands
datatype_vector:
    # Matches v[] when the square brackets are balanced.
    regex: 'v(?<inner>(?<balanced_sqb>\\[[^][]*+(?:(?&balanced_sqb)[^][]*)*+\\]))'
    formatter: 'lindworm.numpy.array([{ group : inner -> [1:-1] }])'

ternary:
    # C-style ternary expressions.
    regex: "\\?(?<inner>[^:]+):"
    formatter: "({ token:1 } if not { token:-1 } else { group:inner })"
